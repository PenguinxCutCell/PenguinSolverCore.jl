var documenterSearchIndex = {"docs":
[{"location":"callbacks/#Callbacks-and-Scheduling","page":"Callbacks and Scheduling","title":"Callbacks and Scheduling","text":"","category":"section"},{"location":"callbacks/#Update-Model","page":"Callbacks and Scheduling","title":"Update Model","text":"An updater is any type that implements:\n\nupdate!(updater, sys, u, p, t) -> Symbol\n\nAllowed return symbols:\n\n:nothing  : no change\n:rhs_only : RHS-only change, no rebuild\n:matrix   : matrix/factorization invalidation\n:geometry : geometry invalidation (rebuild required)\n\nUse UpdateManager plus add_update! to register events.","category":"section"},{"location":"callbacks/#Schedules","page":"Callbacks and Scheduling","title":"Schedules","text":"AtTimes(ts) : fire at specific times (internally normalized/sorted)\nPeriodic(dt, t0) : fire from t0 every dt\nEveryStep() : fire every step (core loop; optional in SciML mode)","category":"section"},{"location":"callbacks/#Core-Driver","page":"Callbacks and Scheduling","title":"Core Driver","text":"apply_scheduled_updates! evaluates schedules, executes updaters, applies invalidation flags, and calls rebuild! exactly once per call if needed.\n\napply_scheduled_updates!(sys, mgr, u, p, t; step = 0)","category":"section"},{"location":"callbacks/#SciML-Behavior","page":"Callbacks and Scheduling","title":"SciML Behavior","text":"With the SciMLBase extension loaded:\n\nAtTimes and Periodic are mapped to DiscreteCallback\ncallback initialization adds tstops for exact stepping at event times\ndue updates at integrator start are also applied during callback initialization\nuser callback can be composed with the core callback via CallbackSet","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Core-System-Hooks","page":"API Reference","title":"Core System Hooks","text":"","category":"section"},{"location":"reference/#Updater-Hook","page":"API Reference","title":"Updater Hook","text":"","category":"section"},{"location":"reference/#Exported-Types-and-Utilities","page":"API Reference","title":"Exported Types and Utilities","text":"AbstractSystem\nAbstractUpdater\nAbstractSchedule\nEveryStep, AtTimes, Periodic\nUpdateEvent, UpdateManager\nnormalize_times, should_fire\nadd_update!, clear_updates!, has_due_updates\nInvalidationCache, invalidate!, clear_invalidations!, needs_rebuild\napply_scheduled_updates!\nsciml_odefunction, sciml_callbackset, sciml_odeproblem (requires SciMLBase extension)\n\nUse ?name in the Julia REPL for available inline docs and method signatures.","category":"section"},{"location":"reference/#PenguinSolverCore.rhs!","page":"API Reference","title":"PenguinSolverCore.rhs!","text":"rhs!(du, sys, u, p, t)\n\nSemidiscrete residual evaluation hook. Physics packages are expected to implement this.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PenguinSolverCore.mass_matrix","page":"API Reference","title":"PenguinSolverCore.mass_matrix","text":"mass_matrix(sys)\n\nOptional mass matrix for semidiscretizations. Return nothing for explicit ODE form.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PenguinSolverCore.apply_updates!","page":"API Reference","title":"PenguinSolverCore.apply_updates!","text":"apply_updates!(sys, u, p, t)\n\nOptional hook to apply smooth time dependence and post-update bookkeeping.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PenguinSolverCore.rebuild!","page":"API Reference","title":"PenguinSolverCore.rebuild!","text":"rebuild!(sys, u, p, t)\n\nOptional hook to rebuild matrices/factorizations after discrete invalidations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PenguinSolverCore.update!","page":"API Reference","title":"PenguinSolverCore.update!","text":"update!(updater, sys, u, p, t) -> Symbol\n\nMutate sys (or p) in-place and return one of: :nothing, :rhs_only, :matrix, or :geometry.\n\n\n\n\n\n","category":"function"},{"location":"#PenguinSolverCore.jl","page":"Home","title":"PenguinSolverCore.jl","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"PenguinSolverCore\")","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"PenguinSolverCore.jl provides shared solver plumbing for Penguin physics packages:\n\nCommon system interface (rhs!, mass_matrix, apply_updates!, rebuild!)\nSolver-agnostic update scheduling (AtTimes, Periodic, EveryStep)\nCache invalidation + rebuild triggering (:rhs_only, :matrix, :geometry)\nOptional SciML bridge for ODEFunction, ODEProblem, and callback mapping","category":"section"},{"location":"#Quick-Example-(Core-Loop)","page":"Home","title":"Quick Example (Core Loop)","text":"using PenguinSolverCore\nimport PenguinSolverCore: rhs!, rebuild!, update!\n\nmutable struct ToySystem <: AbstractSystem\n    val::Float64\n    cache::InvalidationCache\n    updates::UpdateManager\n    rebuild_calls::Int\nend\n\nToySystem() = ToySystem(0.0, InvalidationCache(), UpdateManager(), 0)\n\nrhs!(du, sys::ToySystem, u, p, t) = (du[1] = -u[1] + sys.val)\nrebuild!(sys::ToySystem, u, p, t) = (sys.rebuild_calls += 1)\n\nmutable struct StepUpdater <: AbstractUpdater\n    fired::Vector{Float64}\nend\nStepUpdater() = StepUpdater(Float64[])\n\nfunction update!(upd::StepUpdater, sys::ToySystem, u, p, t)\n    push!(upd.fired, t)\n    sys.val = 2.0\n    return :matrix\nend\n\nsys = ToySystem()\nupd = StepUpdater()\nadd_update!(sys, AtTimes([0.5]), upd)\n\nu = [0.0]\nfor (k, t) in enumerate(0.0:0.25:1.0)\n    apply_scheduled_updates!(sys, u, nothing, t; step = k - 1)\nend\n\n(sys.val, sys.rebuild_calls, upd.fired)","category":"section"},{"location":"#SciML-Bridge","page":"Home","title":"SciML Bridge","text":"If SciMLBase is installed, the package extension provides:\n\nsciml_odefunction(sys; jac, jac_prototype)\nsciml_callbackset(sys; include_every_step = false)\nsciml_odeproblem(sys, u0, tspan; p, callback, include_every_step)\n\nDiscrete update schedules are translated to SciMLBase.DiscreteCallbacks and use add_tstop! for exact event times.","category":"section"},{"location":"#Main-Sections","page":"Home","title":"Main Sections","text":"Callbacks and Scheduling\nAPI Reference","category":"section"}]
}
